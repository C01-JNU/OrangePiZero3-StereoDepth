#version 450
layout(local_size_x = WORKGROUP_X, local_size_y = WORKGROUP_Y) in;
layout(std140, binding = 0) uniform Parameters {
    uint imageWidth, imageHeight, maxDisparity, windowSize;
    float uniquenessRatio, penaltyP1, penaltyP2;
    uint flags, speckleWindow, speckleRange, medianSize, padding[3];
} params;
layout(binding = 1) readonly buffer LeftCensus { uint bits[]; } leftCensus;
layout(binding = 2) readonly buffer RightCensus { uint bits[]; } rightCensus;
layout(binding = 3) writeonly buffer CostVolume { uint cost[]; } costVolume;
layout(binding = 4) readonly buffer Dummy { uint dummy; } dummy;
layout(binding = 5) writeonly buffer Debug { uint data[]; } debug;
uint popcnt(uint x) { return bitCount(x); }
uint hamming64(uint low1, uint high1, uint low2, uint high2) {
    return popcnt(low1 ^ low2) + popcnt(high1 ^ high2);
}
void main() {
    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    if (x >= params.imageWidth || y >= params.imageHeight) return;
    uint pixelIdx = y * params.imageWidth + x;
    uint baseIdx = pixelIdx * 2u;
    uint leftLow = leftCensus.bits[baseIdx];
    uint leftHigh = leftCensus.bits[baseIdx + 1u];
    for (uint d = 0u; d < params.maxDisparity; ++d) {
        uint cost = 64u;
        if (x >= d) {
            uint rightIdx = y * params.imageWidth + (x - d);
            uint rightBase = rightIdx * 2u;
            uint rightLow = rightCensus.bits[rightBase];
            uint rightHigh = rightCensus.bits[rightBase + 1u];
            cost = hamming64(leftLow, leftHigh, rightLow, rightHigh);
        }
        uint volIdx = pixelIdx * params.maxDisparity + d;
        costVolume.cost[volIdx] = cost;
        if (x == 0 && y == 0 && d == 0) {
            debug.data[0] = leftLow; debug.data[1] = leftHigh;
            debug.data[2] = rightCensus.bits[0]; debug.data[3] = rightCensus.bits[1];
            debug.data[4] = cost; debug.data[5] = params.maxDisparity;
        }
    }
}
