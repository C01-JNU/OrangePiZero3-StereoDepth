#version 450
layout(local_size_x = WORKGROUP_X, local_size_y = WORKGROUP_Y) in;
layout(std140, binding = 0) uniform Parameters {
    uint imageWidth, imageHeight, maxDisparity, windowSize;
    float uniquenessRatio, penaltyP1, penaltyP2;
    uint flags, speckleWindow, speckleRange, medianSize, padding[3];
} params;
layout(binding = 1) readonly buffer InputDisparity { uint disp[]; } inDisp;
layout(binding = 3) writeonly buffer OutputDisparity { uint disp[]; } outDisp;
layout(binding = 5) writeonly buffer Debug { uint data[]; } debug;
#define MEDIAN_RADIUS ((MEDIAN_SIZE - 1) / 2)
#define SPECKLE_RADIUS 1
uint medianFilter(uint x, uint y) {
    uint values[MEDIAN_SIZE * MEDIAN_SIZE];
    uint count = 0u;
    for (int dy = -int(MEDIAN_RADIUS); dy <= int(MEDIAN_RADIUS); ++dy) {
        int ny = int(y) + dy;
        if (ny < 0 || ny >= int(params.imageHeight)) continue;
        for (int dx = -int(MEDIAN_RADIUS); dx <= int(MEDIAN_RADIUS); ++dx) {
            int nx = int(x) + dx;
            if (nx < 0 || nx >= int(params.imageWidth)) continue;
            uint idx = uint(ny) * params.imageWidth + uint(nx);
            uint d = inDisp.disp[idx];
            if (d < params.maxDisparity) {
                values[count++] = d;
            }
        }
    }
    if (count == 0u) return params.maxDisparity;
    for (uint i = 0u; i < count - 1u; ++i)
        for (uint j = 0u; j < count - i - 1u; ++j)
            if (values[j] > values[j+1u]) {
                uint t = values[j]; values[j] = values[j+1u]; values[j+1u] = t;
            }
    return values[count / 2u];
}
bool isSpeckle(uint x, uint y, uint d) {
    uint similar = 0u, total = 0u;
    for (int dy = -SPECKLE_RADIUS; dy <= SPECKLE_RADIUS; ++dy) {
        int ny = int(y) + dy;
        if (ny < 0 || ny >= int(params.imageHeight)) continue;
        for (int dx = -SPECKLE_RADIUS; dx <= SPECKLE_RADIUS; ++dx) {
            int nx = int(x) + dx;
            if (nx < 0 || nx >= int(params.imageWidth)) continue;
            total++;
            uint idx = uint(ny) * params.imageWidth + uint(nx);
            uint nd = inDisp.disp[idx];
            if (nd < params.maxDisparity && abs(int(nd) - int(d)) <= int(params.speckleRange))
                similar++;
        }
    }
    return (total > 0u) && (float(similar) / float(total) < 0.5f);
}
void main() {
    uint x = gl_GlobalInvocationID.x, y = gl_GlobalInvocationID.y;
    if (x >= params.imageWidth || y >= params.imageHeight) return;
    uint idx = y * params.imageWidth + x;
    uint d = inDisp.disp[idx];
    uint outD = d;
    if (d < params.maxDisparity) {
        if (IS_FLAG_SET(FLAG_USE_POSTPROCESSING) && isSpeckle(x, y, d))
            outD = params.maxDisparity;
    }
    if (IS_FLAG_SET(FLAG_USE_MEDIAN_FILTER) && outD == params.maxDisparity) {
        uint filtered = medianFilter(x, y);
        if (filtered < params.maxDisparity) outD = filtered;
    }
    outDisp.disp[idx] = outD;
    if (x == 0 && y == 0) {
        debug.data[0] = d; debug.data[1] = outD;
        debug.data[2] = MEDIAN_SIZE; debug.data[3] = params.speckleRange;
    }
}
